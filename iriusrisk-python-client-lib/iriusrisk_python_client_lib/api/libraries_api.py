# coding: utf-8

"""
    IriusRisk API

    IriusRisk provides this featured API to allow for deeper customer integrations as well as enable very flexible automations within the many varied environments IriusRisk needs to operate.  **Beta Version Disclaimer:** Please note that this version of the API is currently in beta. While it offers advanced features for deeper integrations and flexible automations, we reserve the right to make breaking changes during this phase. Backwards compatibility may not be maintained. We encourage users to explore its capabilities but recommend caution in production environments as the API may undergo significant modifications.  # noqa: E501

    OpenAPI spec version: 2.0.0-beta.8
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from iriusrisk_python_client_lib.api_client import ApiClient


class LibrariesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def apply_library_changes(self, body, x_irius_async, library_id, **kwargs):  # noqa: E501
        """Applies library changes to projects.  # noqa: E501

        The library information will be applied to the specified projects, updating their use cases, threats, countermeasures and weaknesses. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_library_changes(body, x_irius_async, library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplyLibraryChangesRequest body: (required)
        :param bool x_irius_async: Sets whether the endpoint works asynchronously or not passed as parameter. (required)
        :param str library_id: ID of the library (required)
        :return: AsyncOperationIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.apply_library_changes_with_http_info(body, x_irius_async, library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.apply_library_changes_with_http_info(body, x_irius_async, library_id, **kwargs)  # noqa: E501
            return data

    def apply_library_changes_with_http_info(self, body, x_irius_async, library_id, **kwargs):  # noqa: E501
        """Applies library changes to projects.  # noqa: E501

        The library information will be applied to the specified projects, updating their use cases, threats, countermeasures and weaknesses. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_library_changes_with_http_info(body, x_irius_async, library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplyLibraryChangesRequest body: (required)
        :param bool x_irius_async: Sets whether the endpoint works asynchronously or not passed as parameter. (required)
        :param str library_id: ID of the library (required)
        :return: AsyncOperationIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'x_irius_async', 'library_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_library_changes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `apply_library_changes`")  # noqa: E501
        # verify the required parameter 'x_irius_async' is set
        if ('x_irius_async' not in params or
                params['x_irius_async'] is None):
            raise ValueError("Missing the required parameter `x_irius_async` when calling `apply_library_changes`")  # noqa: E501
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `apply_library_changes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_irius_async' in params:
            header_params['X-Irius-Async'] = params['x_irius_async']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/projects/apply-changes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_library_countermeasure(self, body, **kwargs):  # noqa: E501
        """Add an existing countermeasure to the selected threat or weakness.  # noqa: E501

        Add an existing countermeasure to the selected threat or weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_library_countermeasure(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyLibraryCountermeasureRequest body: (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_library_countermeasure_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_library_countermeasure_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def copy_library_countermeasure_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add an existing countermeasure to the selected threat or weakness.  # noqa: E501

        Add an existing countermeasure to the selected threat or weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_library_countermeasure_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyLibraryCountermeasureRequest body: (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_library_countermeasure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_library_countermeasure`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_library_weakness(self, body, **kwargs):  # noqa: E501
        """Adds an existing weakness to the selected threat.  # noqa: E501

        Adds an existing weakness to the selected threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_library_weakness(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyLibraryWeaknessRequest body: (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_library_weakness_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_library_weakness_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def copy_library_weakness_with_http_info(self, body, **kwargs):  # noqa: E501
        """Adds an existing weakness to the selected threat.  # noqa: E501

        Adds an existing weakness to the selected threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_library_weakness_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyLibraryWeaknessRequest body: (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_library_weakness" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_library_weakness`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryWeaknessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_threat(self, body, **kwargs):  # noqa: E501
        """An existing threat will be copied to the selected use case.  # noqa: E501

        An existing threat will be copied to the selected use case. Conditions to be able to perform the action: - To have the permission LIBRARY_UPDATE granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_threat(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyThreatRequest body: (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_threat_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_threat_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def copy_threat_with_http_info(self, body, **kwargs):  # noqa: E501
        """An existing threat will be copied to the selected use case.  # noqa: E501

        An existing threat will be copied to the selected use case. Conditions to be able to perform the action: - To have the permission LIBRARY_UPDATE granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_threat_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyThreatRequest body: (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreatResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_countermeasure_comment(self, **kwargs):  # noqa: E501
        """Creates a comment in a library countermeasure.  # noqa: E501

        Creates a new countermeasure comment. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_countermeasure_comment(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryCountermeasureCommentRequest body:
        :return: LibraryCountermeasureCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_countermeasure_comment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_countermeasure_comment_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_countermeasure_comment_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a comment in a library countermeasure.  # noqa: E501

        Creates a new countermeasure comment. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_countermeasure_comment_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryCountermeasureCommentRequest body:
        :return: LibraryCountermeasureCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_countermeasure_comment" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/comments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_countermeasure_test_reference(self, body, **kwargs):  # noqa: E501
        """Creates a reference in a countermeasure test in a library context.  # noqa: E501

        Creates a reference in a countermeasure test in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_countermeasure_test_reference(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureTestReferenceRequest body: (required)
        :return: LibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_countermeasure_test_reference_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_countermeasure_test_reference_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_countermeasure_test_reference_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a reference in a countermeasure test in a library context.  # noqa: E501

        Creates a reference in a countermeasure test in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_countermeasure_test_reference_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureTestReferenceRequest body: (required)
        :return: LibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_countermeasure_test_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_countermeasure_test_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/references', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureTestReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_library(self, body, **kwargs):  # noqa: E501
        """Creates a risk pattern library.  # noqa: E501

        Creates a new risk pattern library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryRequest body: (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_library_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_library_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_library_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a risk pattern library.  # noqa: E501

        Creates a new risk pattern library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryRequest body: (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_library_countermeasure(self, body, **kwargs):  # noqa: E501
        """Creates a new countermeasure within a risk pattern.  # noqa: E501

        Creates the countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureRequest body: (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_library_countermeasure_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_library_countermeasure_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_library_countermeasure_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new countermeasure within a risk pattern.  # noqa: E501

        Creates the countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureRequest body: (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_library_countermeasure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_library_countermeasure`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_library_countermeasure_implementation(self, body, **kwargs):  # noqa: E501
        """Creates a new countermeasure implementation.  # noqa: E501

        Creates an implementation from a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure_implementation(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureImplementationRequest body: (required)
        :return: LibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_library_countermeasure_implementation_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_library_countermeasure_implementation_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_library_countermeasure_implementation_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new countermeasure implementation.  # noqa: E501

        Creates an implementation from a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure_implementation_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureImplementationRequest body: (required)
        :return: LibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_library_countermeasure_implementation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_library_countermeasure_implementation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/implementations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureImplementationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_library_countermeasure_reference(self, body, **kwargs):  # noqa: E501
        """Adds a reference to a library countermeasure.  # noqa: E501

        Adds a reference to a library countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure_reference(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureReferenceRequest body: (required)
        :return: LibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_library_countermeasure_reference_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_library_countermeasure_reference_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_library_countermeasure_reference_with_http_info(self, body, **kwargs):  # noqa: E501
        """Adds a reference to a library countermeasure.  # noqa: E501

        Adds a reference to a library countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure_reference_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureReferenceRequest body: (required)
        :return: LibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_library_countermeasure_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_library_countermeasure_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/references', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_library_countermeasure_standard_reference(self, body, **kwargs):  # noqa: E501
        """Adds a standard reference to a countermeasure in a library context.  # noqa: E501

        Adds a standard reference to a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure_standard_reference(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureStandardReferenceRequest body: (required)
        :return: LibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_library_countermeasure_standard_reference_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_library_countermeasure_standard_reference_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_library_countermeasure_standard_reference_with_http_info(self, body, **kwargs):  # noqa: E501
        """Adds a standard reference to a countermeasure in a library context.  # noqa: E501

        Adds a standard reference to a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_countermeasure_standard_reference_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryCountermeasureStandardReferenceRequest body: (required)
        :return: LibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_library_countermeasure_standard_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_library_countermeasure_standard_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/standard-references', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureStandardReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_library_threat_reference(self, body, **kwargs):  # noqa: E501
        """Creates a new threat reference for a library.  # noqa: E501

        Creates a new threat reference for a library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_threat_reference(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryThreatReferenceRequest body: (required)
        :return: ThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_library_threat_reference_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_library_threat_reference_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_library_threat_reference_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new threat reference for a library.  # noqa: E501

        Creates a new threat reference for a library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_threat_reference_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryThreatReferenceRequest body: (required)
        :return: ThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_library_threat_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_library_threat_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/references', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreatReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_library_weakness(self, body, **kwargs):  # noqa: E501
        """Creates a new weakness within a risk pattern.  # noqa: E501

        Creates the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_weakness(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryWeaknessRequest body: (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_library_weakness_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_library_weakness_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_library_weakness_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new weakness within a risk pattern.  # noqa: E501

        Creates the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_library_weakness_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLibraryWeaknessRequest body: (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_library_weakness" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_library_weakness`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryWeaknessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_risk_pattern(self, body, **kwargs):  # noqa: E501
        """Creates a risk pattern in a library.  # noqa: E501

        Creates a new risk pattern. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_risk_pattern(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateRiskPatternRequest body: (required)
        :return: RiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_risk_pattern_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_risk_pattern_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_risk_pattern_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a risk pattern in a library.  # noqa: E501

        Creates a new risk pattern. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_risk_pattern_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateRiskPatternRequest body: (required)
        :return: RiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_risk_pattern" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_risk_pattern`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/risk-patterns', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RiskPatternResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat(self, body, **kwargs):  # noqa: E501
        """Creates a new threat within a use case.  # noqa: E501

        Creates a new threat within a use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateThreatRequest body: (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_threat_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new threat within a use case.  # noqa: E501

        Creates a new threat within a use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateThreatRequest body: (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreatResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_comment(self, body, **kwargs):  # noqa: E501
        """Creates a comment in a library threat.  # noqa: E501

        Creates a new threat comment. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_comment(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryThreatCommentRequest body: (required)
        :return: LibraryThreatCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_comment_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_comment_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_threat_comment_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a comment in a library threat.  # noqa: E501

        Creates a new threat comment. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_comment_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryThreatCommentRequest body: (required)
        :return: LibraryThreatCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/comments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryThreatCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_use_case(self, body, **kwargs):  # noqa: E501
        """Creates a new use case within a risk pattern.  # noqa: E501

        Creates a new use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_use_case(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateUseCaseRequest body: (required)
        :return: UseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_use_case_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_use_case_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_use_case_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new use case within a risk pattern.  # noqa: E501

        Creates a new use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_use_case_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateUseCaseRequest body: (required)
        :return: UseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_use_case" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_use_case`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/use-cases', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UseCaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_weakness_test_reference(self, body, **kwargs):  # noqa: E501
        """Associates a new reference to a weakness test.  # noqa: E501

        Associates a new reference to a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_weakness_test_reference(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateWeaknessTestReferenceRequest body: (required)
        :return: WeaknessTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_weakness_test_reference_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_weakness_test_reference_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_weakness_test_reference_with_http_info(self, body, **kwargs):  # noqa: E501
        """Associates a new reference to a weakness test.  # noqa: E501

        Associates a new reference to a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_weakness_test_reference_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateWeaknessTestReferenceRequest body: (required)
        :return: WeaknessTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_weakness_test_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_weakness_test_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/tests/references', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WeaknessTestReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_library_by_uuid(self, library_id, **kwargs):  # noqa: E501
        """Deletes a risk pattern library by id  # noqa: E501

        Deletes a risk pattern library by id. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_by_uuid(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_library_by_uuid_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_library_by_uuid_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def delete_library_by_uuid_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Deletes a risk pattern library by id  # noqa: E501

        Deletes a risk pattern library by id. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_by_uuid_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_library_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `delete_library_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_library_countermeasure(self, countermeasure_id, **kwargs):  # noqa: E501
        """Deletes a countermeasure in a library context.  # noqa: E501

        Deletes a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_library_countermeasure_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_library_countermeasure_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
            return data

    def delete_library_countermeasure_with_http_info(self, countermeasure_id, **kwargs):  # noqa: E501
        """Deletes a countermeasure in a library context.  # noqa: E501

        Deletes a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure_with_http_info(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['countermeasure_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_library_countermeasure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `delete_library_countermeasure`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_library_countermeasure1(self, reference_id, **kwargs):  # noqa: E501
        """Deletes a reference in a countermeasure test in a library context.  # noqa: E501

        Deletes a reference in a countermeasure test in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure1(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_library_countermeasure1_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_library_countermeasure1_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def delete_library_countermeasure1_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Deletes a reference in a countermeasure test in a library context.  # noqa: E501

        Deletes a reference in a countermeasure test in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure1_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_library_countermeasure1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `delete_library_countermeasure1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/references/{reference-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_library_countermeasure_implementation(self, implementation_id, **kwargs):  # noqa: E501
        """Deletes an implementation from a countermeasure in a library context.  # noqa: E501

        Deletes an implementation from a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure_implementation(implementation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str implementation_id: The id of the countermeasure implementation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_library_countermeasure_implementation_with_http_info(implementation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_library_countermeasure_implementation_with_http_info(implementation_id, **kwargs)  # noqa: E501
            return data

    def delete_library_countermeasure_implementation_with_http_info(self, implementation_id, **kwargs):  # noqa: E501
        """Deletes an implementation from a countermeasure in a library context.  # noqa: E501

        Deletes an implementation from a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure_implementation_with_http_info(implementation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str implementation_id: The id of the countermeasure implementation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['implementation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_library_countermeasure_implementation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'implementation_id' is set
        if ('implementation_id' not in params or
                params['implementation_id'] is None):
            raise ValueError("Missing the required parameter `implementation_id` when calling `delete_library_countermeasure_implementation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'implementation_id' in params:
            path_params['implementation-id'] = params['implementation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/implementations/{implementation-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_library_countermeasure_reference(self, reference_id, **kwargs):  # noqa: E501
        """Deletes a reference in a countermeasure in a library context.  # noqa: E501

        Deletes a reference in a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure_reference(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_library_countermeasure_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_library_countermeasure_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def delete_library_countermeasure_reference_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Deletes a reference in a countermeasure in a library context.  # noqa: E501

        Deletes a reference in a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure_reference_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_library_countermeasure_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `delete_library_countermeasure_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/references/{reference-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_library_countermeasure_standard_reference(self, standard_reference_id, **kwargs):  # noqa: E501
        """Deletes a countermeasure standard reference.  # noqa: E501

        Deletes a countermeasure standard reference. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure_standard_reference(standard_reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str standard_reference_id: ID of the countermeasure standard reference (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_library_countermeasure_standard_reference_with_http_info(standard_reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_library_countermeasure_standard_reference_with_http_info(standard_reference_id, **kwargs)  # noqa: E501
            return data

    def delete_library_countermeasure_standard_reference_with_http_info(self, standard_reference_id, **kwargs):  # noqa: E501
        """Deletes a countermeasure standard reference.  # noqa: E501

        Deletes a countermeasure standard reference. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_countermeasure_standard_reference_with_http_info(standard_reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str standard_reference_id: ID of the countermeasure standard reference (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['standard_reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_library_countermeasure_standard_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'standard_reference_id' is set
        if ('standard_reference_id' not in params or
                params['standard_reference_id'] is None):
            raise ValueError("Missing the required parameter `standard_reference_id` when calling `delete_library_countermeasure_standard_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'standard_reference_id' in params:
            path_params['standard-reference-id'] = params['standard_reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/standard-references/{standard-reference-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_library_threat_reference(self, reference_id, **kwargs):  # noqa: E501
        """Deletes a threat reference from a library.  # noqa: E501

        Deletes a threat reference from a library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_threat_reference(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_library_threat_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_library_threat_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def delete_library_threat_reference_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Deletes a threat reference from a library.  # noqa: E501

        Deletes a threat reference from a library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_library_threat_reference_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_library_threat_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `delete_library_threat_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/references/{reference-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_risk_pattern_by_id(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Deletes a risk pattern in a library context.  # noqa: E501

        Deletes a risk pattern in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_risk_pattern_by_id(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_risk_pattern_by_id_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_risk_pattern_by_id_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
            return data

    def delete_risk_pattern_by_id_with_http_info(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Deletes a risk pattern in a library context.  # noqa: E501

        Deletes a risk pattern in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_risk_pattern_by_id_with_http_info(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['risk_pattern_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_risk_pattern_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'risk_pattern_id' is set
        if ('risk_pattern_id' not in params or
                params['risk_pattern_id'] is None):
            raise ValueError("Missing the required parameter `risk_pattern_id` when calling `delete_risk_pattern_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'risk_pattern_id' in params:
            path_params['risk-pattern-id'] = params['risk_pattern_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/risk-patterns/{risk-pattern-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_by_uuid(self, threat_id, **kwargs):  # noqa: E501
        """Deletes a threat.  # noqa: E501

        Deletes a threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_by_uuid(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_by_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_by_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def delete_threat_by_uuid_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Deletes a threat.  # noqa: E501

        Deletes a threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_by_uuid_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `delete_threat_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_use_case(self, use_case_id, **kwargs):  # noqa: E501
        """Deletes a use case in a library context.  # noqa: E501

        Deletes the use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_use_case(use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str use_case_id: ID of the use case (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_use_case_with_http_info(use_case_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_use_case_with_http_info(use_case_id, **kwargs)  # noqa: E501
            return data

    def delete_use_case_with_http_info(self, use_case_id, **kwargs):  # noqa: E501
        """Deletes a use case in a library context.  # noqa: E501

        Deletes the use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_use_case_with_http_info(use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str use_case_id: ID of the use case (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['use_case_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_use_case" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'use_case_id' is set
        if ('use_case_id' not in params or
                params['use_case_id'] is None):
            raise ValueError("Missing the required parameter `use_case_id` when calling `delete_use_case`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'use_case_id' in params:
            path_params['use-case-id'] = params['use_case_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/use-cases/{use-case-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_weakness(self, weakness_id, **kwargs):  # noqa: E501
        """Deletes a weakness in a library context.  # noqa: E501

        Deletes the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_weakness(weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_id: ID of the weakness (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_weakness_with_http_info(weakness_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_weakness_with_http_info(weakness_id, **kwargs)  # noqa: E501
            return data

    def delete_weakness_with_http_info(self, weakness_id, **kwargs):  # noqa: E501
        """Deletes a weakness in a library context.  # noqa: E501

        Deletes the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_weakness_with_http_info(weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_id: ID of the weakness (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['weakness_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_weakness" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'weakness_id' is set
        if ('weakness_id' not in params or
                params['weakness_id'] is None):
            raise ValueError("Missing the required parameter `weakness_id` when calling `delete_weakness`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'weakness_id' in params:
            path_params['weakness-id'] = params['weakness_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/{weakness-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_weakness_test_reference(self, reference_id, **kwargs):  # noqa: E501
        """Deletes the reference of a weakness test.  # noqa: E501

        Deletes the reference of a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_weakness_test_reference(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_weakness_test_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_weakness_test_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def delete_weakness_test_reference_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Deletes the reference of a weakness test.  # noqa: E501

        Deletes the reference of a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_weakness_test_reference_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_weakness_test_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `delete_weakness_test_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/tests/references/{reference-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_countermeasure_from_library_threat(self, threat_id, countermeasure_id, **kwargs):  # noqa: E501
        """Unassigns a countermeasure from a library threat.  # noqa: E501

        Unassigns a countermeasure from a library threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_countermeasure_from_library_threat(threat_id, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_countermeasure_from_library_threat_with_http_info(threat_id, countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_countermeasure_from_library_threat_with_http_info(threat_id, countermeasure_id, **kwargs)  # noqa: E501
            return data

    def detach_countermeasure_from_library_threat_with_http_info(self, threat_id, countermeasure_id, **kwargs):  # noqa: E501
        """Unassigns a countermeasure from a library threat.  # noqa: E501

        Unassigns a countermeasure from a library threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_countermeasure_from_library_threat_with_http_info(threat_id, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'countermeasure_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_countermeasure_from_library_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `detach_countermeasure_from_library_threat`")  # noqa: E501
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `detach_countermeasure_from_library_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/countermeasures/{countermeasure-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_countermeasure_from_library_weakness(self, weakness_id, countermeasure_id, **kwargs):  # noqa: E501
        """Unassigns a countermeasure from a library weakness.  # noqa: E501

        Unassigns a countermeasure from a library weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_countermeasure_from_library_weakness(weakness_id, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_id: ID of the weakness (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_countermeasure_from_library_weakness_with_http_info(weakness_id, countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_countermeasure_from_library_weakness_with_http_info(weakness_id, countermeasure_id, **kwargs)  # noqa: E501
            return data

    def detach_countermeasure_from_library_weakness_with_http_info(self, weakness_id, countermeasure_id, **kwargs):  # noqa: E501
        """Unassigns a countermeasure from a library weakness.  # noqa: E501

        Unassigns a countermeasure from a library weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_countermeasure_from_library_weakness_with_http_info(weakness_id, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_id: ID of the weakness (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['weakness_id', 'countermeasure_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_countermeasure_from_library_weakness" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'weakness_id' is set
        if ('weakness_id' not in params or
                params['weakness_id'] is None):
            raise ValueError("Missing the required parameter `weakness_id` when calling `detach_countermeasure_from_library_weakness`")  # noqa: E501
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `detach_countermeasure_from_library_weakness`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'weakness_id' in params:
            path_params['weakness-id'] = params['weakness_id']  # noqa: E501
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/{weakness-id}/countermeasures/{countermeasure-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_weakness_from_library_threat(self, threat_id, weakness_id, **kwargs):  # noqa: E501
        """Unassigns a weakness from a library threat.  # noqa: E501

        Unassigns a weakness from a library threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_weakness_from_library_threat(threat_id, weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str weakness_id: ID of the weakness (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_weakness_from_library_threat_with_http_info(threat_id, weakness_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_weakness_from_library_threat_with_http_info(threat_id, weakness_id, **kwargs)  # noqa: E501
            return data

    def detach_weakness_from_library_threat_with_http_info(self, threat_id, weakness_id, **kwargs):  # noqa: E501
        """Unassigns a weakness from a library threat.  # noqa: E501

        Unassigns a weakness from a library threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_weakness_from_library_threat_with_http_info(threat_id, weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str weakness_id: ID of the weakness (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'weakness_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_weakness_from_library_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `detach_weakness_from_library_threat`")  # noqa: E501
        # verify the required parameter 'weakness_id' is set
        if ('weakness_id' not in params or
                params['weakness_id'] is None):
            raise ValueError("Missing the required parameter `weakness_id` when calling `detach_weakness_from_library_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501
        if 'weakness_id' in params:
            path_params['weakness-id'] = params['weakness_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/weaknesses/{weakness-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_library(self, library_id, **kwargs):  # noqa: E501
        """Disables a risk pattern library by id.  # noqa: E501

        Disables the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_library(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_library_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_library_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def disable_library_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Disables a risk pattern library by id.  # noqa: E501

        Disables the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_library_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `disable_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_library(self, library_id, **kwargs):  # noqa: E501
        """Enables a risk pattern library by id.  # noqa: E501

        Enables the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_library(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_library_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_library_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def enable_library_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Enables a risk pattern library by id.  # noqa: E501

        Enables the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_library_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `enable_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_library_by_uuid(self, library_id, **kwargs):  # noqa: E501
        """Gets a risk pattern library as XML file by id.  # noqa: E501

        Gets the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_library_by_uuid(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_library_by_uuid_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.export_library_by_uuid_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def export_library_by_uuid_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Gets a risk pattern library as XML file by id.  # noqa: E501

        Gets the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_library_by_uuid_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_library_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `export_library_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_countermeasure_comments(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the comments of a countermeasure in a library context.  # noqa: E501

        Gets all the comments of a countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_countermeasure_comments(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: Unique identifier of the countermeasure. (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryCountermeasureCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_countermeasure_comments_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_countermeasure_comments_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
            return data

    def get_all_countermeasure_comments_with_http_info(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the comments of a countermeasure in a library context.  # noqa: E501

        Gets all the comments of a countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_countermeasure_comments_with_http_info(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: Unique identifier of the countermeasure. (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryCountermeasureCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['countermeasure_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_countermeasure_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `get_all_countermeasure_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryCountermeasureCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_libraries(self, **kwargs):  # noqa: E501
        """Gets all libraries.  # noqa: E501

        Gets all the libraries registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_libraries(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_libraries_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_libraries_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_libraries_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all libraries.  # noqa: E501

        Gets all the libraries registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_libraries_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_libraries" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_libraries_countermeasure_summary(self, **kwargs):  # noqa: E501
        """Gets the  list of countermeasure summaries in a library.  # noqa: E501

        Gets the list of countermeasure summaries registered in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_libraries_countermeasure_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibrariesCountermeasuresSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_libraries_countermeasure_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_libraries_countermeasure_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_libraries_countermeasure_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the  list of countermeasure summaries in a library.  # noqa: E501

        Gets the list of countermeasure summaries registered in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_libraries_countermeasure_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibrariesCountermeasuresSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_libraries_countermeasure_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibrariesCountermeasuresSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_libraries_summary(self, **kwargs):  # noqa: E501
        """Gets all the libraries registered in the system.  # noqa: E501

        Gets all the libraries registered in the system containing risk patterns assignable to a component. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_libraries_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibrarySummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_libraries_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_libraries_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_libraries_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all the libraries registered in the system.  # noqa: E501

        Gets all the libraries registered in the system containing risk patterns assignable to a component. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_libraries_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibrarySummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_libraries_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibrarySummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_countermeasure_implementations_by_uuid(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the implementations of a countermeasure in a library context.  # noqa: E501

        Gets all the implementations of a countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasure_implementations_by_uuid(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_countermeasure_implementations_by_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_countermeasure_implementations_by_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
            return data

    def get_all_library_countermeasure_implementations_by_uuid_with_http_info(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the implementations of a countermeasure in a library context.  # noqa: E501

        Gets all the implementations of a countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasure_implementations_by_uuid_with_http_info(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['countermeasure_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_countermeasure_implementations_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `get_all_library_countermeasure_implementations_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}/implementations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryCountermeasureImplementationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_countermeasure_test_references(self, test_id, **kwargs):  # noqa: E501
        """Gets all the references of a countermeasure test in a library context.  # noqa: E501

        Gets all the references of a countermeasure test in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasure_test_references(test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str test_id: ID of the test (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_countermeasure_test_references_with_http_info(test_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_countermeasure_test_references_with_http_info(test_id, **kwargs)  # noqa: E501
            return data

    def get_all_library_countermeasure_test_references_with_http_info(self, test_id, **kwargs):  # noqa: E501
        """Gets all the references of a countermeasure test in a library context.  # noqa: E501

        Gets all the references of a countermeasure test in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasure_test_references_with_http_info(test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str test_id: ID of the test (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['test_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_countermeasure_test_references" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'test_id' is set
        if ('test_id' not in params or
                params['test_id'] is None):
            raise ValueError("Missing the required parameter `test_id` when calling `get_all_library_countermeasure_test_references`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'test_id' in params:
            path_params['test-id'] = params['test_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/{test-id}/references', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelGetAllLibraryCountermeasureTestReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_countermeasures(self, **kwargs):  # noqa: E501
        """Gets all the library countermeasures.  # noqa: E501

        Gets all the library countermeasures registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted, or, - To have the permission **COUNTERMEASURE_CREATE** granted, or, - To have the permission **COUNTERMEASURE_ADD_FROM_EXISTING** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_countermeasures_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_countermeasures_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_library_countermeasures_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all the library countermeasures.  # noqa: E501

        Gets all the library countermeasures registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted, or, - To have the permission **COUNTERMEASURE_CREATE** granted, or, - To have the permission **COUNTERMEASURE_ADD_FROM_EXISTING** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_countermeasures" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelGetAllLibraryCountermeasureResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_countermeasures_by_threat_uuid(self, threat_id, **kwargs):  # noqa: E501
        """Gets all the library countermeasures in a threat.  # noqa: E501

        Gets all the library countermeasures registered in the system associated with the threat identified by the given id. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures_by_threat_uuid(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_countermeasures_by_threat_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_countermeasures_by_threat_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def get_all_library_countermeasures_by_threat_uuid_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Gets all the library countermeasures in a threat.  # noqa: E501

        Gets all the library countermeasures registered in the system associated with the threat identified by the given id. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures_by_threat_uuid_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_countermeasures_by_threat_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_all_library_countermeasures_by_threat_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/countermeasures', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryThreatCountermeasureResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_countermeasures_summary(self, library_id, **kwargs):  # noqa: E501
        """Gets the  list of countermeasure summaries in a library.  # noqa: E501

        Gets the list of countermeasure summaries registered in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures_summary(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelCountermeasureSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_countermeasures_summary_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_countermeasures_summary_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def get_all_library_countermeasures_summary_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Gets the  list of countermeasure summaries in a library.  # noqa: E501

        Gets the list of countermeasure summaries registered in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures_summary_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelCountermeasureSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_countermeasures_summary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `get_all_library_countermeasures_summary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/countermeasures/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelCountermeasureSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_countermeasures_summary_by_threat_uuid(self, threat_id, **kwargs):  # noqa: E501
        """Gets a summary of all the library countermeasures in a threat.  # noqa: E501

        Gets a summary of all the library countermeasures registered in the system associated with the threat identified by the given id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures_summary_by_threat_uuid(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatCountermeasureSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_countermeasures_summary_by_threat_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_countermeasures_summary_by_threat_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def get_all_library_countermeasures_summary_by_threat_uuid_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Gets a summary of all the library countermeasures in a threat.  # noqa: E501

        Gets a summary of all the library countermeasures registered in the system associated with the threat identified by the given id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_countermeasures_summary_by_threat_uuid_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatCountermeasureSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_countermeasures_summary_by_threat_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_all_library_countermeasures_summary_by_threat_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/countermeasures/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryThreatCountermeasureSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_threat_references(self, threat_id, **kwargs):  # noqa: E501
        """Obtains the library threat references through the threat id.  # noqa: E501

        Gets the library threat references details. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_threat_references(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: Unique identifier of the threat. (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_threat_references_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_threat_references_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def get_all_library_threat_references_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Obtains the library threat references through the threat id.  # noqa: E501

        Gets the library threat references details. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_threat_references_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: Unique identifier of the threat. (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_threat_references" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_all_library_threat_references`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/references', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelThreatReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_threats_summary(self, **kwargs):  # noqa: E501
        """Gets the summary threat list in a library context.  # noqa: E501

        Gets the summary threat list. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_threats_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_threats_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_threats_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_library_threats_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the summary threat list in a library context.  # noqa: E501

        Gets the summary threat list. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_threats_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_threats_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryThreatSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_weaknesses(self, **kwargs):  # noqa: E501
        """Gets all the library weaknesses.  # noqa: E501

        Gets all the library weaknesses registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted, or, - To have the permission **THREAT_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_weaknesses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_weaknesses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_weaknesses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_library_weaknesses_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all the library weaknesses.  # noqa: E501

        Gets all the library weaknesses registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted, or, - To have the permission **THREAT_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_weaknesses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_weaknesses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryWeaknessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_library_weaknesses_by_threat(self, threat_id, **kwargs):  # noqa: E501
        """Gets all the library weaknesses in a threat.  # noqa: E501

        Gets all the library weaknesses registered in the system associated with the threat identified by the given id. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_weaknesses_by_threat(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_library_weaknesses_by_threat_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_library_weaknesses_by_threat_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def get_all_library_weaknesses_by_threat_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Gets all the library weaknesses in a threat.  # noqa: E501

        Gets all the library weaknesses registered in the system associated with the threat identified by the given id. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_library_weaknesses_by_threat_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_library_weaknesses_by_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_all_library_weaknesses_by_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/weaknesses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryThreatWeaknessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_projects_for_library(self, library_id, **kwargs):  # noqa: E501
        """Gets all the projects related with the given library.  # noqa: E501

        Gets all the projects related with the given library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_projects_for_library(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_projects_for_library_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_projects_for_library_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def get_all_projects_for_library_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Gets all the projects related with the given library.  # noqa: E501

        Gets all the projects related with the given library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_projects_for_library_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_projects_for_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `get_all_projects_for_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_references_by_countermeasure_uuid(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the references of a countermeasure in a library context.  # noqa: E501

        Gets all the references of a countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_references_by_countermeasure_uuid(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_references_by_countermeasure_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_references_by_countermeasure_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
            return data

    def get_all_references_by_countermeasure_uuid_with_http_info(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the references of a countermeasure in a library context.  # noqa: E501

        Gets all the references of a countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_references_by_countermeasure_uuid_with_http_info(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['countermeasure_id', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_references_by_countermeasure_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `get_all_references_by_countermeasure_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}/references', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelGetAllLibraryCountermeasureReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_risk_patterns_for_library(self, library_id, **kwargs):  # noqa: E501
        """Gets all the risk patterns in a library.  # noqa: E501

        Gets all the risk patterns registered in the system associated with the library identified by the given id. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_risk_patterns_for_library(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelRiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_risk_patterns_for_library_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_risk_patterns_for_library_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def get_all_risk_patterns_for_library_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Gets all the risk patterns in a library.  # noqa: E501

        Gets all the risk patterns registered in the system associated with the library identified by the given id. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_risk_patterns_for_library_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelRiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_risk_patterns_for_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `get_all_risk_patterns_for_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/risk-patterns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelRiskPatternResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_risk_patterns_summary_for_library(self, library_id, **kwargs):  # noqa: E501
        """Gets the summary list of risk patterns in a library.  # noqa: E501

        Gets the summary list of risk patterns registered in the system associated with the library identified by the given id. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_risk_patterns_summary_for_library(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelRiskPatternSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_risk_patterns_summary_for_library_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_risk_patterns_summary_for_library_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def get_all_risk_patterns_summary_for_library_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Gets the summary list of risk patterns in a library.  # noqa: E501

        Gets the summary list of risk patterns registered in the system associated with the library identified by the given id. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_risk_patterns_summary_for_library_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelRiskPatternSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_risk_patterns_summary_for_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `get_all_risk_patterns_summary_for_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/risk-patterns/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelRiskPatternSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_standard_references_by_countermeasure_uuid(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the standard references associated with a given countermeasure in a library context.  # noqa: E501

        Gets all the standard references associated with a given countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_standard_references_by_countermeasure_uuid(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_standard_references_by_countermeasure_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_standard_references_by_countermeasure_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
            return data

    def get_all_standard_references_by_countermeasure_uuid_with_http_info(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets all the standard references associated with a given countermeasure in a library context.  # noqa: E501

        Gets all the standard references associated with a given countermeasure in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_standard_references_by_countermeasure_uuid_with_http_info(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['countermeasure_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_standard_references_by_countermeasure_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `get_all_standard_references_by_countermeasure_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}/standard-references', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryCountermeasureStandardReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_summary_threats_by_library_use_case(self, use_case_id, **kwargs):  # noqa: E501
        """Given a use case, returns the summary list of its threats.  # noqa: E501

        Given a use case, returns the summary list of its threats. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_summary_threats_by_library_use_case(use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str use_case_id: ID of the use case (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelThreatSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_summary_threats_by_library_use_case_with_http_info(use_case_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_summary_threats_by_library_use_case_with_http_info(use_case_id, **kwargs)  # noqa: E501
            return data

    def get_all_summary_threats_by_library_use_case_with_http_info(self, use_case_id, **kwargs):  # noqa: E501
        """Given a use case, returns the summary list of its threats.  # noqa: E501

        Given a use case, returns the summary list of its threats. Conditions to be able to perform the action: - The user must be authenticated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_summary_threats_by_library_use_case_with_http_info(use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str use_case_id: ID of the use case (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelThreatSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['use_case_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_summary_threats_by_library_use_case" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'use_case_id' is set
        if ('use_case_id' not in params or
                params['use_case_id'] is None):
            raise ValueError("Missing the required parameter `use_case_id` when calling `get_all_summary_threats_by_library_use_case`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'use_case_id' in params:
            path_params['use-case-id'] = params['use_case_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/use-cases/{use-case-id}/threats/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelThreatSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_threat_comments(self, threat_id, **kwargs):  # noqa: E501
        """Gets all the comments of a threat in a library context.  # noqa: E501

        Gets all the comments of a threat in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_threat_comments(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: Unique identifier of the threat. (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_threat_comments_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_threat_comments_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def get_all_threat_comments_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Gets all the comments of a threat in a library context.  # noqa: E501

        Gets all the comments of a threat in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_threat_comments_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: Unique identifier of the threat. (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryThreatCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_threat_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_all_threat_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryThreatCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_threats(self, **kwargs):  # noqa: E501
        """Gets all threats.  # noqa: E501

        Gets all threats. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted, or, - To have the permission **THREAT_CREATE** granted, or, - To have the permission **THREAT_ADD_FROM_EXISTING** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_threats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_threats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_threats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_threats_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all threats.  # noqa: E501

        Gets all threats. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted, or, - To have the permission **THREAT_CREATE** granted, or, - To have the permission **THREAT_ADD_FROM_EXISTING** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_threats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelGetAllLibraryThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_threats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelGetAllLibraryThreatResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_threats_summaries(self, library_id, **kwargs):  # noqa: E501
        """Gets the summary threat list from a library.  # noqa: E501

        Gets the list of threats id, reference and name from a library.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_threats_summaries(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelThreatSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_threats_summaries_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_threats_summaries_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def get_all_threats_summaries_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Gets the summary threat list from a library.  # noqa: E501

        Gets the list of threats id, reference and name from a library.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_threats_summaries_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelThreatSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_threats_summaries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `get_all_threats_summaries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/threats/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelThreatSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_use_cases_for_risk_pattern(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Gets all the use cases of a risk pattern in a library context.  # noqa: E501

        Gets all the use cases of a risk pattern in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_use_cases_for_risk_pattern(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelUseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_use_cases_for_risk_pattern_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_use_cases_for_risk_pattern_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
            return data

    def get_all_use_cases_for_risk_pattern_with_http_info(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Gets all the use cases of a risk pattern in a library context.  # noqa: E501

        Gets all the use cases of a risk pattern in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_use_cases_for_risk_pattern_with_http_info(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelUseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['risk_pattern_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_use_cases_for_risk_pattern" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'risk_pattern_id' is set
        if ('risk_pattern_id' not in params or
                params['risk_pattern_id'] is None):
            raise ValueError("Missing the required parameter `risk_pattern_id` when calling `get_all_use_cases_for_risk_pattern`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'risk_pattern_id' in params:
            path_params['risk-pattern-id'] = params['risk_pattern_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/risk-patterns/{risk-pattern-id}/use-cases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelUseCaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_use_cases_summary_for_risk_pattern(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Gets the summary list of use cases of a risk pattern in a library context.  # noqa: E501

        Gets the summary list of use cases of a risk pattern in a library context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_use_cases_summary_for_risk_pattern(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelUseCaseSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_use_cases_summary_for_risk_pattern_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_use_cases_summary_for_risk_pattern_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
            return data

    def get_all_use_cases_summary_for_risk_pattern_with_http_info(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Gets the summary list of use cases of a risk pattern in a library context.  # noqa: E501

        Gets the summary list of use cases of a risk pattern in a library context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_use_cases_summary_for_risk_pattern_with_http_info(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelUseCaseSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['risk_pattern_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_use_cases_summary_for_risk_pattern" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'risk_pattern_id' is set
        if ('risk_pattern_id' not in params or
                params['risk_pattern_id'] is None):
            raise ValueError("Missing the required parameter `risk_pattern_id` when calling `get_all_use_cases_summary_for_risk_pattern`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'risk_pattern_id' in params:
            path_params['risk-pattern-id'] = params['risk_pattern_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/risk-patterns/{risk-pattern-id}/use-cases/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelUseCaseSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_weakness_test_reference(self, weakness_test_id, **kwargs):  # noqa: E501
        """Gets all the references of a weakness test.  # noqa: E501

        Gets all the references of a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_weakness_test_reference(weakness_test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_test_id: ID of the weakness test. (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelWeaknessTestReferencesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_weakness_test_reference_with_http_info(weakness_test_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_weakness_test_reference_with_http_info(weakness_test_id, **kwargs)  # noqa: E501
            return data

    def get_all_weakness_test_reference_with_http_info(self, weakness_test_id, **kwargs):  # noqa: E501
        """Gets all the references of a weakness test.  # noqa: E501

        Gets all the references of a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_weakness_test_reference_with_http_info(weakness_test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_test_id: ID of the weakness test. (required)
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelWeaknessTestReferencesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['weakness_test_id', 'filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_weakness_test_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'weakness_test_id' is set
        if ('weakness_test_id' not in params or
                params['weakness_test_id'] is None):
            raise ValueError("Missing the required parameter `weakness_test_id` when calling `get_all_weakness_test_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'weakness_test_id' in params:
            path_params['weakness-test-id'] = params['weakness_test_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/tests/{weakness-test-id}/references', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelWeaknessTestReferencesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_weaknesses_summary(self, **kwargs):  # noqa: E501
        """Gets the list of weakness summaries in the system.  # noqa: E501

        Gets the list of weakness summaries registered in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_weaknesses_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryWeaknessSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_weaknesses_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_weaknesses_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_weaknesses_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the list of weakness summaries in the system.  # noqa: E501

        Gets the list of weakness summaries registered in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_weaknesses_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter to apply to the returned items. It is possible to filter by any property of the response.  The full filter string must be passed in a single **filter** query parameter. Providing multiple **filter** parameters will lead to unexpected results. Both the properties and values must be enclosed in single quotation marks. | Operator | Description | Example | | -------- | ----------- |-------- | | =        | Returns items where the property **equals** to the value           | /resources?filter=**'field'='value'** | | =NULL    | Returns items where the property **is null**, it has no value     | /resources?filter=**'field'=NULL** | | <>       | Returns items where the property is **not equal** to the value     | /resources?filter=**'field'<>'value'** | | <>NULL   | Returns items where the property **is not null**, it has any value     | /resources?filter=**'field'<>NULL** | | >        | Returns items where the property is **bigger<sup>1</sup>** than the value   | /resources?filter=**'field'>'value'** | | <        | Returns items where the property is **smaller<sup>1</sup>** than the value  | /resources?filter=**'field'<'value'** | | >=       | Returns items where the property is **bigger<sup>1</sup> or equal** to the value      | /resources?filter=**'field'>='value'** | | <=       | Returns items where the property is **smaller<sup>1</sup> or equal** to the value     | /resources?filter=**'field'<='value'** | | ~        | Returns items where the string property **contains, ignorecase**, the value  | /resources?filter=**'field'~'value'** | | IN       | Returns items where the list property **contains** any of the values | /resources?filter=**'field'IN'value1,value2,...'** | | :AND:    | Returns items that comply with **both** filters                | /resources?filter=**'field1'='value1':AND:'field2'<>'value2'** | | :OR:     | Returns items that comply with **at least one** of the filters | /resources?filter=**'field1'='value1':OR:'field2'<>'value2'** | ---  <sup>1</sup> Bigger and smaller according to normal sorting. Applicable to: dates, timestamps, numbers, strings. The following data types support filtering: - Boolean - String - Enumerations - Numeric - Dates - Timestamps  **AND** and **OR** operators can be combined. They can be grouped using parenthesis. Example: ``` /resources?filter=('field1'='value1':OR:'field2'='value2'):AND:('field3'<>'value3':OR:'field4'='value4') ```
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelLibraryWeaknessSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_weaknesses_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelLibraryWeaknessSummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_by_uuid(self, library_id, **kwargs):  # noqa: E501
        """Gets a risk pattern library by id.  # noqa: E501

        Gets the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_by_uuid(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_by_uuid_with_http_info(library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_by_uuid_with_http_info(library_id, **kwargs)  # noqa: E501
            return data

    def get_library_by_uuid_with_http_info(self, library_id, **kwargs):  # noqa: E501
        """Gets a risk pattern library by id.  # noqa: E501

        Gets the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_by_uuid_with_http_info(library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library_id: ID of the library (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `get_library_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_by_uuid(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets a countermeasure in a library context  # noqa: E501

        Gets the countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_by_uuid(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_by_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_by_uuid_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_by_uuid_with_http_info(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets a countermeasure in a library context  # noqa: E501

        Gets the countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_by_uuid_with_http_info(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['countermeasure_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `get_library_countermeasure_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_history(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets the history records for a countermeasure.  # noqa: E501

        Gets the historical changes for a countermeasure, ordered by most recent by default. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_history(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_history_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_history_with_http_info(countermeasure_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_history_with_http_info(self, countermeasure_id, **kwargs):  # noqa: E501
        """Gets the history records for a countermeasure.  # noqa: E501

        Gets the historical changes for a countermeasure, ordered by most recent by default. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_history_with_http_info(countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str countermeasure_id: ID of the countermeasure (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['countermeasure_id', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `get_library_countermeasure_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelHistoryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_implementation_by_uuid(self, implementation_id, **kwargs):  # noqa: E501
        """Gets the countermeasure implementation details.  # noqa: E501

        Gets the countermeasure implementation details. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_implementation_by_uuid(implementation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str implementation_id: The id of the countermeasure implementation. (required)
        :return: LibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_implementation_by_uuid_with_http_info(implementation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_implementation_by_uuid_with_http_info(implementation_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_implementation_by_uuid_with_http_info(self, implementation_id, **kwargs):  # noqa: E501
        """Gets the countermeasure implementation details.  # noqa: E501

        Gets the countermeasure implementation details. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_implementation_by_uuid_with_http_info(implementation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str implementation_id: The id of the countermeasure implementation. (required)
        :return: LibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['implementation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_implementation_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'implementation_id' is set
        if ('implementation_id' not in params or
                params['implementation_id'] is None):
            raise ValueError("Missing the required parameter `implementation_id` when calling `get_library_countermeasure_implementation_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'implementation_id' in params:
            path_params['implementation-id'] = params['implementation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/implementations/{implementation-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureImplementationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_reference(self, reference_id, **kwargs):  # noqa: E501
        """Gets a specific countermeasure reference of the library.  # noqa: E501

        Gets a specific countermeasure reference of the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_reference(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_reference_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Gets a specific countermeasure reference of the library.  # noqa: E501

        Gets a specific countermeasure reference of the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_reference_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `get_library_countermeasure_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/references/{reference-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_standard_reference(self, standard_reference_id, **kwargs):  # noqa: E501
        """Gets a specific countermeasure standard reference of the library.  # noqa: E501

        Gets a specific countermeasure standard reference of the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_standard_reference(standard_reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str standard_reference_id: ID of the countermeasure standard reference (required)
        :return: LibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_standard_reference_with_http_info(standard_reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_standard_reference_with_http_info(standard_reference_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_standard_reference_with_http_info(self, standard_reference_id, **kwargs):  # noqa: E501
        """Gets a specific countermeasure standard reference of the library.  # noqa: E501

        Gets a specific countermeasure standard reference of the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_standard_reference_with_http_info(standard_reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str standard_reference_id: ID of the countermeasure standard reference (required)
        :return: LibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['standard_reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_standard_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'standard_reference_id' is set
        if ('standard_reference_id' not in params or
                params['standard_reference_id'] is None):
            raise ValueError("Missing the required parameter `standard_reference_id` when calling `get_library_countermeasure_standard_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'standard_reference_id' in params:
            path_params['standard-reference-id'] = params['standard_reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/standard-references/{standard-reference-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureStandardReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_test_by_uuid(self, test_id, **kwargs):  # noqa: E501
        """Gets the test related to a countermeasure.  # noqa: E501

        Gets the test related to a countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_test_by_uuid(test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str test_id: ID of the test (required)
        :return: GetLibraryCountermeasureTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_test_by_uuid_with_http_info(test_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_test_by_uuid_with_http_info(test_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_test_by_uuid_with_http_info(self, test_id, **kwargs):  # noqa: E501
        """Gets the test related to a countermeasure.  # noqa: E501

        Gets the test related to a countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_test_by_uuid_with_http_info(test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str test_id: ID of the test (required)
        :return: GetLibraryCountermeasureTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['test_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_test_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'test_id' is set
        if ('test_id' not in params or
                params['test_id'] is None):
            raise ValueError("Missing the required parameter `test_id` when calling `get_library_countermeasure_test_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'test_id' in params:
            path_params['test-id'] = params['test_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/{test-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetLibraryCountermeasureTestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_test_history(self, test_id, **kwargs):  # noqa: E501
        """Gets the history records for a countermeasure test.  # noqa: E501

        Gets the historical changes for a countermeasure test, ordered by most recent by default. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_test_history(test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str test_id: ID of the test (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_test_history_with_http_info(test_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_test_history_with_http_info(test_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_test_history_with_http_info(self, test_id, **kwargs):  # noqa: E501
        """Gets the history records for a countermeasure test.  # noqa: E501

        Gets the historical changes for a countermeasure test, ordered by most recent by default. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_test_history_with_http_info(test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str test_id: ID of the test (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['test_id', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_test_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'test_id' is set
        if ('test_id' not in params or
                params['test_id'] is None):
            raise ValueError("Missing the required parameter `test_id` when calling `get_library_countermeasure_test_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'test_id' in params:
            path_params['test-id'] = params['test_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/{test-id}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelHistoryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_countermeasure_test_reference(self, reference_id, **kwargs):  # noqa: E501
        """Gets the reference details of a countermeasure test in a library context.  # noqa: E501

        Gets the reference details of a countermeasure test in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_test_reference(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_countermeasure_test_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_countermeasure_test_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def get_library_countermeasure_test_reference_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Gets the reference details of a countermeasure test in a library context.  # noqa: E501

        Gets the reference details of a countermeasure test in a library context registered in the system. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_countermeasure_test_reference_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_countermeasure_test_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `get_library_countermeasure_test_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/references/{reference-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureTestReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_threat_reference(self, reference_id, **kwargs):  # noqa: E501
        """Gets a specific threat reference of the library.  # noqa: E501

        Gets a specific threat reference of the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_threat_reference(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: ThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_threat_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_threat_reference_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def get_library_threat_reference_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Gets a specific threat reference of the library.  # noqa: E501

        Gets a specific threat reference of the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted or - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_threat_reference_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: ThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_threat_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `get_library_threat_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/references/{reference-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreatReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_library_weakness_by_uuid(self, weakness_id, **kwargs):  # noqa: E501
        """Gets a weakness in a library context.  # noqa: E501

        Gets the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_weakness_by_uuid(weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_id: ID of the weakness (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_library_weakness_by_uuid_with_http_info(weakness_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_library_weakness_by_uuid_with_http_info(weakness_id, **kwargs)  # noqa: E501
            return data

    def get_library_weakness_by_uuid_with_http_info(self, weakness_id, **kwargs):  # noqa: E501
        """Gets a weakness in a library context.  # noqa: E501

        Gets the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_library_weakness_by_uuid_with_http_info(weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_id: ID of the weakness (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['weakness_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_library_weakness_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'weakness_id' is set
        if ('weakness_id' not in params or
                params['weakness_id'] is None):
            raise ValueError("Missing the required parameter `weakness_id` when calling `get_library_weakness_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'weakness_id' in params:
            path_params['weakness-id'] = params['weakness_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/{weakness-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryWeaknessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_risk_pattern_by_uuid(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Gets a risk pattern in a library context.  # noqa: E501

        Gets the risk pattern. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_risk_pattern_by_uuid(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :return: RiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_risk_pattern_by_uuid_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_risk_pattern_by_uuid_with_http_info(risk_pattern_id, **kwargs)  # noqa: E501
            return data

    def get_risk_pattern_by_uuid_with_http_info(self, risk_pattern_id, **kwargs):  # noqa: E501
        """Gets a risk pattern in a library context.  # noqa: E501

        Gets the risk pattern. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_risk_pattern_by_uuid_with_http_info(risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str risk_pattern_id: ID of the risk pattern (required)
        :return: RiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['risk_pattern_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_risk_pattern_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'risk_pattern_id' is set
        if ('risk_pattern_id' not in params or
                params['risk_pattern_id'] is None):
            raise ValueError("Missing the required parameter `risk_pattern_id` when calling `get_risk_pattern_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'risk_pattern_id' in params:
            path_params['risk-pattern-id'] = params['risk_pattern_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/risk-patterns/{risk-pattern-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RiskPatternResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_by_uuid(self, threat_id, **kwargs):  # noqa: E501
        """Gets a threat by id.  # noqa: E501

        Gets the threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_by_uuid(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_by_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_by_uuid_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def get_threat_by_uuid_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Gets a threat by id.  # noqa: E501

        Gets the threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_by_uuid_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_threat_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreatResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_history(self, threat_id, **kwargs):  # noqa: E501
        """Gets the history records for a threat.  # noqa: E501

        Gets the historical changes for a threat, ordered by most recent by default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_history(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_history_with_http_info(threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_history_with_http_info(threat_id, **kwargs)  # noqa: E501
            return data

    def get_threat_history_with_http_info(self, threat_id, **kwargs):  # noqa: E501
        """Gets the history records for a threat.  # noqa: E501

        Gets the historical changes for a threat, ordered by most recent by default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_history_with_http_info(threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_id: ID of the threat (required)
        :param int page: Zero-based page index (0..N)
        :param int size: The size of the page to be returned
        :param list[str] sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :return: PagedModelHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_id', 'page', 'size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_threat_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedModelHistoryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_use_case_by_id1(self, use_case_id, **kwargs):  # noqa: E501
        """Gets a use case in a library context.  # noqa: E501

        Gets the use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_use_case_by_id1(use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str use_case_id: ID of the use case (required)
        :return: UseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_use_case_by_id1_with_http_info(use_case_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_use_case_by_id1_with_http_info(use_case_id, **kwargs)  # noqa: E501
            return data

    def get_use_case_by_id1_with_http_info(self, use_case_id, **kwargs):  # noqa: E501
        """Gets a use case in a library context.  # noqa: E501

        Gets the use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_use_case_by_id1_with_http_info(use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str use_case_id: ID of the use case (required)
        :return: UseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['use_case_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_use_case_by_id1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'use_case_id' is set
        if ('use_case_id' not in params or
                params['use_case_id'] is None):
            raise ValueError("Missing the required parameter `use_case_id` when calling `get_use_case_by_id1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'use_case_id' in params:
            path_params['use-case-id'] = params['use_case_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/use-cases/{use-case-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UseCaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_weakness_test(self, weakness_test_id, **kwargs):  # noqa: E501
        """Gets the test related to a weakness.  # noqa: E501

        Gets the test related to a weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_weakness_test(weakness_test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_test_id: ID of the weakness test. (required)
        :return: WeaknessTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_weakness_test_with_http_info(weakness_test_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_weakness_test_with_http_info(weakness_test_id, **kwargs)  # noqa: E501
            return data

    def get_weakness_test_with_http_info(self, weakness_test_id, **kwargs):  # noqa: E501
        """Gets the test related to a weakness.  # noqa: E501

        Gets the test related to a weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_weakness_test_with_http_info(weakness_test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weakness_test_id: ID of the weakness test. (required)
        :return: WeaknessTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['weakness_test_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_weakness_test" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'weakness_test_id' is set
        if ('weakness_test_id' not in params or
                params['weakness_test_id'] is None):
            raise ValueError("Missing the required parameter `weakness_test_id` when calling `get_weakness_test`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'weakness_test_id' in params:
            path_params['weakness-test-id'] = params['weakness_test_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/tests/{weakness-test-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WeaknessTestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_weakness_test_reference_by_uuid(self, reference_id, **kwargs):  # noqa: E501
        """Gets the reference of a weakness test details.  # noqa: E501

        Gets the reference of a weakness test details. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_weakness_test_reference_by_uuid(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: WeaknessTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_weakness_test_reference_by_uuid_with_http_info(reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_weakness_test_reference_by_uuid_with_http_info(reference_id, **kwargs)  # noqa: E501
            return data

    def get_weakness_test_reference_by_uuid_with_http_info(self, reference_id, **kwargs):  # noqa: E501
        """Gets the reference of a weakness test details.  # noqa: E501

        Gets the reference of a weakness test details. Conditions to be able to perform the action: - To have the permission **LIBRARY_VIEW** granted, or, - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_weakness_test_reference_by_uuid_with_http_info(reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference_id: ID of a reference. (required)
        :return: WeaknessTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_weakness_test_reference_by_uuid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `get_weakness_test_reference_by_uuid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/tests/references/{reference-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WeaknessTestReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_library(self, file, reference_id, name, **kwargs):  # noqa: E501
        """Imports a risk pattern library from XML file.  # noqa: E501

        Imports risk pattern library from XML file. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_library(file, reference_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str reference_id: (required)
        :param str name: (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_library_with_http_info(file, reference_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.import_library_with_http_info(file, reference_id, name, **kwargs)  # noqa: E501
            return data

    def import_library_with_http_info(self, file, reference_id, name, **kwargs):  # noqa: E501
        """Imports a risk pattern library from XML file.  # noqa: E501

        Imports risk pattern library from XML file. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_library_with_http_info(file, reference_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str reference_id: (required)
        :param str name: (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'reference_id', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `import_library`")  # noqa: E501
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `import_library`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `import_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'reference_id' in params:
            form_params.append(('referenceId', params['reference_id']))  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library(self, body, library_id, **kwargs):  # noqa: E501
        """Modifies the library.  # noqa: E501

        Modifies the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library(body, library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryRequest body: (required)
        :param str library_id: ID of the library (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_with_http_info(body, library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_with_http_info(body, library_id, **kwargs)  # noqa: E501
            return data

    def update_library_with_http_info(self, body, library_id, **kwargs):  # noqa: E501
        """Modifies the library.  # noqa: E501

        Modifies the library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_with_http_info(body, library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LibraryRequest body: (required)
        :param str library_id: ID of the library (required)
        :return: LibraryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'library_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library`")  # noqa: E501
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `update_library`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_by_xml_file(self, x_irius_async, library_id, **kwargs):  # noqa: E501
        """Modifies the library from an XML file.  # noqa: E501

        Modifies the library from an XML file upload. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_by_xml_file(x_irius_async, library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool x_irius_async: Sets whether the endpoint works asynchronously or not passed as parameter. (required)
        :param str library_id: ID of the library (required)
        :param str file:
        :return: AsyncOperationIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_by_xml_file_with_http_info(x_irius_async, library_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_by_xml_file_with_http_info(x_irius_async, library_id, **kwargs)  # noqa: E501
            return data

    def update_library_by_xml_file_with_http_info(self, x_irius_async, library_id, **kwargs):  # noqa: E501
        """Modifies the library from an XML file.  # noqa: E501

        Modifies the library from an XML file upload. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_by_xml_file_with_http_info(x_irius_async, library_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool x_irius_async: Sets whether the endpoint works asynchronously or not passed as parameter. (required)
        :param str library_id: ID of the library (required)
        :param str file:
        :return: AsyncOperationIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_irius_async', 'library_id', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_by_xml_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'x_irius_async' is set
        if ('x_irius_async' not in params or
                params['x_irius_async'] is None):
            raise ValueError("Missing the required parameter `x_irius_async` when calling `update_library_by_xml_file`")  # noqa: E501
        # verify the required parameter 'library_id' is set
        if ('library_id' not in params or
                params['library_id'] is None):
            raise ValueError("Missing the required parameter `library_id` when calling `update_library_by_xml_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library_id' in params:
            path_params['library-id'] = params['library_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_irius_async' in params:
            header_params['X-Irius-Async'] = params['x_irius_async']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/{library-id}/update-with-file', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_countermeasure(self, body, countermeasure_id, **kwargs):  # noqa: E501
        """Updates a countermeasure in a library context.  # noqa: E501

        Updates the countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure(body, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureRequest body: (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_countermeasure_with_http_info(body, countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_countermeasure_with_http_info(body, countermeasure_id, **kwargs)  # noqa: E501
            return data

    def update_library_countermeasure_with_http_info(self, body, countermeasure_id, **kwargs):  # noqa: E501
        """Updates a countermeasure in a library context.  # noqa: E501

        Updates the countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_with_http_info(body, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureRequest body: (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'countermeasure_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_countermeasure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_countermeasure`")  # noqa: E501
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `update_library_countermeasure`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_countermeasure_implementation(self, body, implementation_id, **kwargs):  # noqa: E501
        """Updates an implementation from a countermeasure in a library context.  # noqa: E501

        Updates an implementation from a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_implementation(body, implementation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureImplementationRequest body: (required)
        :param str implementation_id: The id of the countermeasure implementation. (required)
        :return: LibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_countermeasure_implementation_with_http_info(body, implementation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_countermeasure_implementation_with_http_info(body, implementation_id, **kwargs)  # noqa: E501
            return data

    def update_library_countermeasure_implementation_with_http_info(self, body, implementation_id, **kwargs):  # noqa: E501
        """Updates an implementation from a countermeasure in a library context.  # noqa: E501

        Updates an implementation from a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_implementation_with_http_info(body, implementation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureImplementationRequest body: (required)
        :param str implementation_id: The id of the countermeasure implementation. (required)
        :return: LibraryCountermeasureImplementationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'implementation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_countermeasure_implementation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_countermeasure_implementation`")  # noqa: E501
        # verify the required parameter 'implementation_id' is set
        if ('implementation_id' not in params or
                params['implementation_id'] is None):
            raise ValueError("Missing the required parameter `implementation_id` when calling `update_library_countermeasure_implementation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'implementation_id' in params:
            path_params['implementation-id'] = params['implementation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/implementations/{implementation-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureImplementationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_countermeasure_reference(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates a reference in a countermeasure in a library context.  # noqa: E501

        Updates a reference in a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_reference(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_countermeasure_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_countermeasure_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
            return data

    def update_library_countermeasure_reference_with_http_info(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates a reference in a countermeasure in a library context.  # noqa: E501

        Updates a reference in a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_reference_with_http_info(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_countermeasure_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_countermeasure_reference`")  # noqa: E501
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `update_library_countermeasure_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/references/{reference-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_countermeasure_standard_reference(self, body, standard_reference_id, **kwargs):  # noqa: E501
        """Updates a standard reference in a countermeasure in a library context.  # noqa: E501

        Updates a standard reference in a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_standard_reference(body, standard_reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureStandardReferenceRequest body: (required)
        :param str standard_reference_id: ID of the countermeasure standard reference (required)
        :return: LibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_countermeasure_standard_reference_with_http_info(body, standard_reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_countermeasure_standard_reference_with_http_info(body, standard_reference_id, **kwargs)  # noqa: E501
            return data

    def update_library_countermeasure_standard_reference_with_http_info(self, body, standard_reference_id, **kwargs):  # noqa: E501
        """Updates a standard reference in a countermeasure in a library context.  # noqa: E501

        Updates a standard reference in a countermeasure in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_standard_reference_with_http_info(body, standard_reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureStandardReferenceRequest body: (required)
        :param str standard_reference_id: ID of the countermeasure standard reference (required)
        :return: LibraryCountermeasureStandardReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'standard_reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_countermeasure_standard_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_countermeasure_standard_reference`")  # noqa: E501
        # verify the required parameter 'standard_reference_id' is set
        if ('standard_reference_id' not in params or
                params['standard_reference_id'] is None):
            raise ValueError("Missing the required parameter `standard_reference_id` when calling `update_library_countermeasure_standard_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'standard_reference_id' in params:
            path_params['standard-reference-id'] = params['standard_reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/standard-references/{standard-reference-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureStandardReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_countermeasure_state(self, body, countermeasure_id, **kwargs):  # noqa: E501
        """Updates the status of a library countermeasure.  # noqa: E501

        Updates the status of a library countermeasure.  A reason must be given for these transitions: rejected or not-applicable.  Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_state(body, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CountermeasureidStateBody2 body: (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_countermeasure_state_with_http_info(body, countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_countermeasure_state_with_http_info(body, countermeasure_id, **kwargs)  # noqa: E501
            return data

    def update_library_countermeasure_state_with_http_info(self, body, countermeasure_id, **kwargs):  # noqa: E501
        """Updates the status of a library countermeasure.  # noqa: E501

        Updates the status of a library countermeasure.  A reason must be given for these transitions: rejected or not-applicable.  Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_state_with_http_info(body, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CountermeasureidStateBody2 body: (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryCountermeasureResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'countermeasure_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_countermeasure_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_countermeasure_state`")  # noqa: E501
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `update_library_countermeasure_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/{countermeasure-id}/state', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_countermeasure_test(self, body, test_id, **kwargs):  # noqa: E501
        """Updates the test related to a countermeasure.  # noqa: E501

        Updates the test related to a countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_test(body, test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureTestRequest body: (required)
        :param str test_id: ID of the test (required)
        :return: GetLibraryCountermeasureTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_countermeasure_test_with_http_info(body, test_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_countermeasure_test_with_http_info(body, test_id, **kwargs)  # noqa: E501
            return data

    def update_library_countermeasure_test_with_http_info(self, body, test_id, **kwargs):  # noqa: E501
        """Updates the test related to a countermeasure.  # noqa: E501

        Updates the test related to a countermeasure. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_test_with_http_info(body, test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureTestRequest body: (required)
        :param str test_id: ID of the test (required)
        :return: GetLibraryCountermeasureTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'test_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_countermeasure_test" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_countermeasure_test`")  # noqa: E501
        # verify the required parameter 'test_id' is set
        if ('test_id' not in params or
                params['test_id'] is None):
            raise ValueError("Missing the required parameter `test_id` when calling `update_library_countermeasure_test`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'test_id' in params:
            path_params['test-id'] = params['test_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/{test-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetLibraryCountermeasureTestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_countermeasure_test_reference(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates a reference in a countermeasure test in a library context.  # noqa: E501

        Updates a reference in a countermeasure test in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_test_reference(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureTestReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_countermeasure_test_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_countermeasure_test_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
            return data

    def update_library_countermeasure_test_reference_with_http_info(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates a reference in a countermeasure test in a library context.  # noqa: E501

        Updates a reference in a countermeasure test in a library context. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_countermeasure_test_reference_with_http_info(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryCountermeasureTestReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: LibraryCountermeasureTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_countermeasure_test_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_countermeasure_test_reference`")  # noqa: E501
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `update_library_countermeasure_test_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/countermeasures/tests/references/{reference-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryCountermeasureTestReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_threat_countermeasure_mitigation(self, body, threat_id, countermeasure_id, **kwargs):  # noqa: E501
        """Modifies the mitigation of a countermeasure in a threat.  # noqa: E501

        Modifies the mitigation of the association of a countermeasure and a threat identified by their ids. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_threat_countermeasure_mitigation(body, threat_id, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateMitigationRequest body: (required)
        :param str threat_id: ID of the threat (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryThreatCountermeasureMitigationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_threat_countermeasure_mitigation_with_http_info(body, threat_id, countermeasure_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_threat_countermeasure_mitigation_with_http_info(body, threat_id, countermeasure_id, **kwargs)  # noqa: E501
            return data

    def update_library_threat_countermeasure_mitigation_with_http_info(self, body, threat_id, countermeasure_id, **kwargs):  # noqa: E501
        """Modifies the mitigation of a countermeasure in a threat.  # noqa: E501

        Modifies the mitigation of the association of a countermeasure and a threat identified by their ids. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_threat_countermeasure_mitigation_with_http_info(body, threat_id, countermeasure_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateMitigationRequest body: (required)
        :param str threat_id: ID of the threat (required)
        :param str countermeasure_id: ID of the countermeasure (required)
        :return: LibraryThreatCountermeasureMitigationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_id', 'countermeasure_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_threat_countermeasure_mitigation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_threat_countermeasure_mitigation`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `update_library_threat_countermeasure_mitigation`")  # noqa: E501
        # verify the required parameter 'countermeasure_id' is set
        if ('countermeasure_id' not in params or
                params['countermeasure_id'] is None):
            raise ValueError("Missing the required parameter `countermeasure_id` when calling `update_library_threat_countermeasure_mitigation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501
        if 'countermeasure_id' in params:
            path_params['countermeasure-id'] = params['countermeasure_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}/countermeasures/{countermeasure-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryThreatCountermeasureMitigationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_library_threat_reference(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates a reference for a threat of a library.  # noqa: E501

        Updates a reference for a threat of a library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_threat_reference(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryThreatReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: ThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_library_threat_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_library_threat_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
            return data

    def update_library_threat_reference_with_http_info(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates a reference for a threat of a library.  # noqa: E501

        Updates a reference for a threat of a library. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_library_threat_reference_with_http_info(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryThreatReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: ThreatReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_library_threat_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_library_threat_reference`")  # noqa: E501
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `update_library_threat_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/references/{reference-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreatReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_risk_pattern(self, body, risk_pattern_id, **kwargs):  # noqa: E501
        """Modifies the risk pattern in a library context.  # noqa: E501

        Modifies the risk pattern. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_risk_pattern(body, risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateRiskPatternRequest body: (required)
        :param str risk_pattern_id: ID of the risk pattern (required)
        :return: RiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_risk_pattern_with_http_info(body, risk_pattern_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_risk_pattern_with_http_info(body, risk_pattern_id, **kwargs)  # noqa: E501
            return data

    def update_risk_pattern_with_http_info(self, body, risk_pattern_id, **kwargs):  # noqa: E501
        """Modifies the risk pattern in a library context.  # noqa: E501

        Modifies the risk pattern. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_risk_pattern_with_http_info(body, risk_pattern_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateRiskPatternRequest body: (required)
        :param str risk_pattern_id: ID of the risk pattern (required)
        :return: RiskPatternResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'risk_pattern_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_risk_pattern" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_risk_pattern`")  # noqa: E501
        # verify the required parameter 'risk_pattern_id' is set
        if ('risk_pattern_id' not in params or
                params['risk_pattern_id'] is None):
            raise ValueError("Missing the required parameter `risk_pattern_id` when calling `update_risk_pattern`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'risk_pattern_id' in params:
            path_params['risk-pattern-id'] = params['risk_pattern_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/risk-patterns/{risk-pattern-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RiskPatternResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat(self, body, threat_id, **kwargs):  # noqa: E501
        """Modifies the threat.  # noqa: E501

        Modifies the threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat(body, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateThreatRequest body: (required)
        :param str threat_id: ID of the threat (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_with_http_info(body, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_with_http_info(body, threat_id, **kwargs)  # noqa: E501
            return data

    def update_threat_with_http_info(self, body, threat_id, **kwargs):  # noqa: E501
        """Modifies the threat.  # noqa: E501

        Modifies the threat. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_with_http_info(body, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateThreatRequest body: (required)
        :param str threat_id: ID of the threat (required)
        :return: ThreatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `update_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_id' in params:
            path_params['threat-id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/threats/{threat-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreatResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_use_case(self, body, use_case_id, **kwargs):  # noqa: E501
        """Updates a use case in a library context.  # noqa: E501

        Updates the use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_use_case(body, use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateUseCaseRequest body: (required)
        :param str use_case_id: ID of the use case (required)
        :return: UseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_use_case_with_http_info(body, use_case_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_use_case_with_http_info(body, use_case_id, **kwargs)  # noqa: E501
            return data

    def update_use_case_with_http_info(self, body, use_case_id, **kwargs):  # noqa: E501
        """Updates a use case in a library context.  # noqa: E501

        Updates the use case. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_use_case_with_http_info(body, use_case_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateUseCaseRequest body: (required)
        :param str use_case_id: ID of the use case (required)
        :return: UseCaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'use_case_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_use_case" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_use_case`")  # noqa: E501
        # verify the required parameter 'use_case_id' is set
        if ('use_case_id' not in params or
                params['use_case_id'] is None):
            raise ValueError("Missing the required parameter `use_case_id` when calling `update_use_case`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'use_case_id' in params:
            path_params['use-case-id'] = params['use_case_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/use-cases/{use-case-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UseCaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_weakness(self, body, weakness_id, **kwargs):  # noqa: E501
        """Updates a weakness in a library context.  # noqa: E501

        Updates the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_weakness(body, weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryWeaknessRequest body: (required)
        :param str weakness_id: ID of the weakness (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_weakness_with_http_info(body, weakness_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_weakness_with_http_info(body, weakness_id, **kwargs)  # noqa: E501
            return data

    def update_weakness_with_http_info(self, body, weakness_id, **kwargs):  # noqa: E501
        """Updates a weakness in a library context.  # noqa: E501

        Updates the weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_weakness_with_http_info(body, weakness_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLibraryWeaknessRequest body: (required)
        :param str weakness_id: ID of the weakness (required)
        :return: LibraryWeaknessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'weakness_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_weakness" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_weakness`")  # noqa: E501
        # verify the required parameter 'weakness_id' is set
        if ('weakness_id' not in params or
                params['weakness_id'] is None):
            raise ValueError("Missing the required parameter `weakness_id` when calling `update_weakness`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'weakness_id' in params:
            path_params['weakness-id'] = params['weakness_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/{weakness-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryWeaknessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_weakness_test(self, body, weakness_test_id, **kwargs):  # noqa: E501
        """Updates the test related to a weakness.  # noqa: E501

        Updates the test related to a weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_weakness_test(body, weakness_test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateWeaknessTestRequest body: (required)
        :param str weakness_test_id: ID of the weakness test. (required)
        :return: WeaknessTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_weakness_test_with_http_info(body, weakness_test_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_weakness_test_with_http_info(body, weakness_test_id, **kwargs)  # noqa: E501
            return data

    def update_weakness_test_with_http_info(self, body, weakness_test_id, **kwargs):  # noqa: E501
        """Updates the test related to a weakness.  # noqa: E501

        Updates the test related to a weakness. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_weakness_test_with_http_info(body, weakness_test_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateWeaknessTestRequest body: (required)
        :param str weakness_test_id: ID of the weakness test. (required)
        :return: WeaknessTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'weakness_test_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_weakness_test" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_weakness_test`")  # noqa: E501
        # verify the required parameter 'weakness_test_id' is set
        if ('weakness_test_id' not in params or
                params['weakness_test_id'] is None):
            raise ValueError("Missing the required parameter `weakness_test_id` when calling `update_weakness_test`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'weakness_test_id' in params:
            path_params['weakness-test-id'] = params['weakness_test_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/tests/{weakness-test-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WeaknessTestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_weakness_test_reference(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates the reference of a weakness test.  # noqa: E501

        Updates the reference of a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_weakness_test_reference(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateWeaknessTestReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: WeaknessTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_weakness_test_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_weakness_test_reference_with_http_info(body, reference_id, **kwargs)  # noqa: E501
            return data

    def update_weakness_test_reference_with_http_info(self, body, reference_id, **kwargs):  # noqa: E501
        """Updates the reference of a weakness test.  # noqa: E501

        Updates the reference of a weakness test. Conditions to be able to perform the action: - To have the permission **LIBRARY_UPDATE** granted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_weakness_test_reference_with_http_info(body, reference_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateWeaknessTestReferenceRequest body: (required)
        :param str reference_id: ID of a reference. (required)
        :return: WeaknessTestReferenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'reference_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_weakness_test_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_weakness_test_reference`")  # noqa: E501
        # verify the required parameter 'reference_id' is set
        if ('reference_id' not in params or
                params['reference_id'] is None):
            raise ValueError("Missing the required parameter `reference_id` when calling `update_weakness_test_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reference_id' in params:
            path_params['reference-id'] = params['reference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api-token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/libraries/weaknesses/tests/references/{reference-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WeaknessTestReferenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
